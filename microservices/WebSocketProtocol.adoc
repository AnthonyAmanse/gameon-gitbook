= WebSocket Protocol
:icons: font
:toc: preamble
:toc-title:
:toclevels: 3
:swagger: https://game-on.org/swagger/

WebSockets are currently used for two-way asynchronous communication between the Client
(the player's web browser) and the Mediator, and between the Mediator and a Room.
The Mediator is playing man-in-the-middle, and the goal is to allow as much message
routing as possible to happen without requiring the Mediator to look at the JSON data.

The protocol used by Game On! is text (rather than binary), and uses a simple
comma-delimited header followed by a JSON payload, `just,like,{"this": "ok?"}`.

* The first section, e.g. `just` in the example above, indicates the direction
  of the message.
** `player` is used for messages destined for the player/client.
** `playerLocation` is interpreted by the Mediator and also sent to the
    player/client.
** `room*` is used for messages destined for the room.
* The middle section, e.g. `like` in the example above, indicates the recipient
  of the message. This element is not present in all messages.
** For player-directed messages, it is either the specific player's ID, or `*`
   for messages intended for all players.
** For room-directed messages, it is the specific room's ID.
* The last section is a JSON payload, e.g. `{"this": "ok?"}`. The contents
  vary by message type.

All message formats are documented below, grouped by the sender. Note that
implementations of a client/front-end or a room need to understand both how to
send required messages, but also how to receive and process messages of different
types that will be sent in their direction. A sequence diagram follows to help
explain the flow of messages.


== Messages sent by the Client

=== Client -> Mediator, ready message

----
ready,{
    "mediatorId": "cached-id",
    "roomId": "cached-room-id",
    "bookmark": "id",
    "client-version": [1]
}
----

Note that the data in the ready message is what the client had cached. It is
used to determine whether or not history replay applies.

The client-version field is a list of number, and the only version supported by
the mediator currently is '1'. If the version attribute is missing, it is assumed
to be 1.

=== Client -> Mediator, sos message

----
sos,*,{
    "username": "username",
    "userId": "<userId>"
    "content": "<message>"
}
----

Help! The SOS message is sent to the mediator by the client on behalf of a
player who is either stuck or bored and just wants a fast-path back to
First Room.

=== Client -> Mediator -> Room, chat/command message

----
room,<roomId>,{
    "username": "username",
    "userId": "<userId>"
    "content": "<message>"
}
----

The target room id is sent as part of the comma-delimited header so that the
mediator can discard the message if it arrives after the player has switched rooms.

The content sent from the client is a single text line (just as the player
entered it). If it begins with `/`, it is a command; if it doesn't, it's just
chatter.

<<<

== Messages sent by the Mediator

=== Mediator -> Client, progress messages

----
player,<playerId>,{
    "type": "joinpart",
    "content": "text update"
}
----

These are short messages that the Mediator sends while managing room connections.

=== Mediator -> Client, acknowledgement (ack) message

----
ack,{
    "mediatorId": "assigned-id",
    "roomId": "current-room-id",
    "commands": {
        "/help": "...",
        ...
    },
    "client-version": 1
  }
----

Sent when the connection between the client and the mediator is first established,
and again whenever the player's location changes, as an assist for cache-refreshes.

The commands included in the `ack` are the common commands that are always supported.

If the client-version attribute is missing, it is assumed to be 1.

=== Mediator -> Room, roomHello message

----
roomHello,<roomId>,{
    "username": "username",
    "userId": "<userId>",
    "version": 1
}
----

Sent when a player joins or reconnects to a room.
Version is the version of this WebSocket protocol selected by the mediator to
use when communicating with the room.
Currently the only supported version is '1'

=== Mediator -> Room, roomGoodbye message

----
roomGoodbye,<roomId>,{
    "username": "username",
    "userId": "<userId>",
}
----

Sent when a player leaves the room to go to another room, e.g. after a `/go *`
or `/sos` command.

<<<

== Messages sent by the Room

Rooms can always broadcast everything to everyone. These messages have a place
for the player id in the routing information. A specific player id or `*` can
be used. The Mediator will filter based on the supplied player id when relaying
events to clients.

=== Room -> Mediator, acknowledgement (ack) with version

This packet should be sent when the WebSocket is opened, and indicates the
possible versions of this WebSocket communication protocol supported by the
room (or rooms) behind this WebSocket endpoint.

----
ack,{
    "version": [1]
  }
----

The version field is a list of number, and the only version supported by the
mediator currently is '1'.

=== Room -> Mediator -> Client, location message

Send information about the room to the client. This message is sent after
receiving a `roomHello`.

----
player,<playerId>,{
    "type": "location",
    "name": "Room name",
    "fullName": "Room's descriptive full name",
    "description", "Lots of text about what the room looks like",
    "exits": {
        "shortDirection" : "currentDescription for Player",
        "N" :  "a dark entranceway"
    },
    "commands": {
        "/custom" : "Description of what command does"
    },
    "roomInventory": ["itemA","itemB"]
}
----

Note: Some attributes, like "exits", "commands", and "roomInventory" can also be
sent with other room events as a pseudo-push notification

=== Room -> Mediator -> Client, chat messages

----
player,*,{...}
{
  "type": "chat",
  "username": "username",
  "content": "<message>",
  "bookmark": <long room-specific message id>
}
----

Content is a simple string containing the chat message.

=== Room -> Mediator -> Client, Event message

----
player,<playerId>,{
    "type": "event",
    "content": {
        "*": "general text for everyone",
        "<playerId>": "specific to player"
        },
    "bookmark": <long room-specific message id>
}
player,*,{
    "type": "event",
    "content": {
        "*": "general text for everyone",
        "<playerId>": "specific to player"
    },
    "bookmark": <long room-specific message id>
}
----

Events can be routed specifically to a player, or can be broadcast to everyone.
The content can also be directed to specific users vs. all users. The structure
is the same to make it easier to deal with consistently. Typical patterns would be:

----
player,playerA,{
    "type":"event",
    "content": {"*": "You feel the earth move"},
    "bookmark": 231
}

player,*,{
    "type":"event".
    "content": {
        "playerA": "You feel the earth move",
        "*": "playerA looks rather ill"
    },
    "bookmark": 245
}
----

=== Room -> Mediator -> Client, playerLocation message

Indicates that a player can leave by the requested exit (`exitId`). The `exit`
attribute, if present, should return the exit details as returned by the map API.
The `exit` attribute is not required, but must be present if the details to be
used are not present in the map.

----
playerLocation,<playerId>,{
    "type": "exit",
    "content": "You exit through door xyz... ",
    "bookmark": <room-specific message id>,
    "exitId": "N"
    "exit": { ... }
}
----

This must be directed to a specific player.

<<<

== Sequence diagram

This diagram won't win any design competitions, but it does give a general idea
the way messages flow between the Client, the Mediator, and Rooms.

image:../images/sequences.svg["Sequence diagram",align="center"]

Additional notes:

* First Room is part of the Mediator. It obeys the WebSocket protocol in terms
  of messages sent back and forth, but communication with First Room does not
  occur over a WebSocket.
