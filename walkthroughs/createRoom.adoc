= Creating Rooms
:icons: font
:toc: preamble
:toc-title:
:toclevels: 2
:12-factor: link:../about/12-factor.adoc
:api-key: link:../microservices/ApplicationSecurity.adoc
:cf-javascript: https://github.com/gameontext/gameon-room-nodejs#introduction
:cf-java: https://github.com/gameontext/gameon-room-java#introduction
:docker-go: https://github.com/gameontext/gameon-room-go#introduction
:docker-java: https://github.com/gameontext/gameon-room-java-docker#introduction
:first-room: https://game-on.org/#/play
:swagger: https://game-on.org/swagger/
:sweep: link:../microservices/TheSweep.adoc
:websocket: link:../microservices/WebSocketProtocol.adoc

Creating a simple microservice that provides a room can take as little as 15
minutes. The base requirements are pretty simple: A room is a service
registered with the Map that minimally obeys the {websocket}[WebSocket protocol]
for user interactions.

[NOTE]
====
Room registration is long-lived: the registration for your room
will persist until you delete it. You can list and delete your registered
rooms using commands in {first-room}[First Room].
====

== Create a room as a Cloud Foundry application

A simple, initial version of a room can be stood up in minutes as
a Cloud Foundry application.

* {cf-javascript}[Create a Game On! Room in JavaScript]
* {cf-java}[Create a Game On! Room in Java]

Once your basic room service is running, {first-room}[navigate or teleport] to
it to make sure it is working, then consider <<what-next,what to try next>>.

== Create a room using Docker

* {docker-go}[Create a Game On! Room in Go using Docker containers]
* {docker-java}[Create a Game On! Room in Java using Docker containers]

Developing and testing your room locally in a production-like
environment is an important aspect of {12-factor}[Twelve factor
applications], as it reduces the likelihood that what you create
locally will fail in new and unexpected ways when activated in
production.

We support local development and test using Docker Compose. The walkthroughs
above contain `docker-compose.yml` files, with example overlays for local
development.

== Send your room's logs to ELK (beta)

Once you've created a room, the next thing you'll want to do is figure out how to send the room's logs somewhere so that when your room is stopped (and its local filesystem disappears) you don't lose your diagnostic data.  You also will want to be able to view your logs, and other events, from a dashboard to make it easy to find problems without having to look at each room's files one at a time.

Each Bluemix space has its own dedicated place to store logs and other events.  This event storage is a multi-tenant ELK setup.  ELK is Elasticsearch, Logstash, and Kibana.  Behind the scenes Bluemix uses Logstash to ingest events and forward them to its Elasticsearch instance.  Elasticsearch stores and indexes your events.  You use your browser to interact with Kibana, which provides customizable dashboards using events it queries from Elasticsearch.  To ensure security, each Bluemix space has its own separate Elasticsearch tenant.

=== Send your Java room's logs to ELK

If your room is running on Liberty, and you have a Bluemix org/space, you can set up your server to send its events to Bluemix's ELK in under 5 minutes.  Liberty has a convenient command, the bluemixUtility, to help you leverage services in Bluemix.

Log in to your Bluemix org/space using Liberty's bluemixUtility.  This tells the bluemixUtility which org/space to target.

- US South:
```
bluemixUtility login --api=us-south --user=yourUserName --password=yourPassword --org=yourOrg --space=yourSpace
```


- United Kingdom:
```
bluemixUtility login --api=eu-gb --user=yourUserName --password=yourPassword --org=yourOrg --space=yourSpace
```


Use bluemixUtility to import a Liberty configuration snippet for sending events to the Bluemix log service.  Note that trace and access logs are not enabled in your Liberty server by default -- if they are not enabled explicitly in your server.xml then no trace / access logs will be sent to the Bluemix log service.

```
bluemixUtility import bluemixLog --psource="message,trace,garbageCollection,ffdc,accessLog"
```

Use bluemixUtility to configure your Liberty server to use the configuration snippet you just downloaded.
```
bluemixUtility bind defaultServer bluemixLog
```

Your Liberty server will now send its events to the ELK tenant in the Bluemix org/space you specified.


=== Deploy your ELK-enabled server to Bluemix Cloud Foundry

You can run your ELK-enabled Liberty server in Bluemix Cloud Foundry.

As a workaround to a beta issue, you'll need to add bluemixLogCollector-1.1 directly to your server.xml's featureManager section as follows:

```
<featureManager>
    <feature>bluemixLogCollector-1.1</feature>
</featureManager>
```

The Liberty bluemixLogCollector-1.1 feature, which is what sends your events to Bluemix, is currently in beta.  To run your room in Bluemix Cloud Foundry, tell the Liberty buildpack to use the beta version of the Liberty runtime:

```
server package defaultServer --include=usr
cf push myApp -p defaultServer.zip
cf set-env myApp IBM_LIBERTY_BETA true
cf set-env myApp JBP_CONFIG_LIBERTY "version: +"
cf restage myApp
```

Take a look at your log file in Bluemix CF to make sure things are running as expected. 

```
cf files theBadApp logs/messages.log  
```

You should see a message similar to the following:

```
[7/25/16 1:53:27:437 UTC] 00000029 com.ibm.ws.logmet.collector.internal.LogmetClient            I TRAS0214I: The collector is connected to the Bluemix log collection server on the specified host logs.eu-gb.opvis.bluemix.net and port number 9091.
```

=== Use your Kibana dashboard to see your log (and other) events

Once you have your log (and other) events going to Bluemix's ELK you can use Kibana's powerful dashboards to explore your data.

To access your Kibana dashboard, use the URL below that matches where your Bluemix space is located:

- US South: https://logmet.ng.bluemix.net/
- United Kingdom: https://logmet.eu-gb.bluemix.net/

Initially you will see the default Kibana dashboard.  This dashboard shows you log and trace events over time from all servers that have sent their events to that Bluemix org/space's ELK tenant.  You can zoom in on a particular time range by clicking on the graph and dragging across the time range you want to see.

To see the Liberty dashboard, click the load (folder) icon in the top right corner of the Kibana interface and select the Liberty-K3-* choice.  A set of tables and graphs specific to Liberty should appear.  A few things you can try:

- look at the Hosts / User Directories / Servers row to see if you can spot your server.  The "count" shows how many events have been consumed by Elasticsearch in the time window you are looking at.  If you are sending data from multiple servers to ELK, try clicking on the magnifying glass icon to filter in only the server you are interested in.  Filters apply to the whole dashboard.
- look at the Hot Messages / Hot Response Codes / Slow Hits / Slow GC row to see if there are any highlights you need to be aware of immediately.
- expand each of the collapsed rows (for example, the Record Counts - Logs row, or the Garbage Collection Row) to explore your data.
- try zooming in on a time range by clicking and dragging across a time range on a graph - look for correlations between graphs (for example a long hit duration at about the same time as a message printed to your logs) when you zoom.
- expand rows near the bottom (messages table, access log table, and others) to see the your actual logs, trace, access logs, ffdc and garbage collection events.
- feeling adventurous?  Try clicking "ADD A ROW" at the bottom of the dashboard and adding your own visualizations -- there are lots of youtube videos showing how to use Kibana!

== Visits from the Sweep

Registered rooms are visited periodically by {sweep}[the Sweep].
The Sweep will score rooms based on on availabilty, and adherance
to the Room API (primarily the {websocket}[WebSocket protocol].

Rooms in the map will move based on their score, with high-scoring
rooms moving toward the center (closer to First Room), and low-scoring
rooms moving toward the periphery.

[[what-next]]
== What next?

Let's say you want to make the most popular room ever (an admirable
goal), which means your room will need to scale to more than one
instance. How do you propagate chat and events across scaled room
instances to make sure that it feels like one big room?

You might also explore creating several rooms that relate to each other.
Should each service be an individual room, or would quantum entanglement
between the rooms make the bounded context be the suite, rather than any
individual room? Would rooms need share state or communicate? Given that
services should remain fiercely independent, where does that state go?
